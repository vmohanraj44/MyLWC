"use strict";
/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
exports.MAX_BATCH_REQUEST_SIZE = 25;
class SObjectDescribe {
    constructor(connection) {
        this.servicesPath = 'services/data';
        // the targetVersion should be consistent with the Cli even if only using REST calls
        this.targetVersion = '46.0';
        this.versionPrefix = 'v';
        this.sobjectsPart = 'sobjects';
        this.batchPart = 'composite/batch';
        this.connection = connection;
    }
    /**
     * Method that returns a list of SObjects based on running a describe global request
     * More info at https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/resources_describeGlobal.htm
     * @returns Promise<SObjectShortDescription[]> containing the sobject names and 'custom' classification
     */
    describeGlobal() {
        return __awaiter(this, void 0, void 0, function* () {
            const allDescriptions = yield this.connection.describeGlobal();
            const requestedDescriptions = allDescriptions.sobjects.map(sobject => {
                return { name: sobject.name, custom: sobject.custom };
            });
            return requestedDescriptions;
        });
    }
    getVersion() {
        return `${this.versionPrefix}${this.targetVersion}`;
    }
    buildSObjectDescribeURL(sObjectName) {
        const urlElements = [
            this.getVersion(),
            this.sobjectsPart,
            sObjectName,
            'describe'
        ];
        return urlElements.join('/');
    }
    buildBatchRequestURL() {
        const batchUrlElements = [
            this.connection.instanceUrl,
            this.servicesPath,
            this.getVersion(),
            this.batchPart
        ];
        return batchUrlElements.join('/');
    }
    buildBatchRequestBody(types) {
        const batchRequest = { batchRequests: [] };
        for (const objType of types) {
            batchRequest.batchRequests.push({
                method: 'GET',
                url: this.buildSObjectDescribeURL(objType)
            });
        }
        return batchRequest;
    }
    runRequest(batchRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.request({
                method: 'POST',
                url: this.buildBatchRequestURL(),
                body: JSON.stringify(batchRequest),
                headers: {
                    'User-Agent': 'salesforcedx-extension',
                    'Sforce-Call-Options': `client=${constants_1.CLIENT_ID}`
                }
            });
        });
    }
    describeSObjectBatchRequest(types) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const batchRequest = this.buildBatchRequestBody(types);
                const batchResponse = yield this.runRequest(batchRequest);
                const fetchedObjects = [];
                if (batchResponse && batchResponse.results === undefined) {
                    return Promise.resolve(fetchedObjects);
                }
                batchResponse.results.forEach((sr, i) => {
                    if (sr.result instanceof Array) {
                        if (sr.result[0].errorCode && sr.result[0].message) {
                            console.log(`Error: ${sr.result[0].message} - ${types[i]}`);
                        }
                    }
                    else
                        fetchedObjects.push(toMinimalSObject(sr.result));
                });
                return Promise.resolve(fetchedObjects);
            }
            catch (error) {
                const errorMsg = error.hasOwnProperty('body')
                    ? error.body
                    : error.message;
                return Promise.reject(errorMsg);
            }
        });
    }
    fetchObjects(types) {
        return __awaiter(this, void 0, void 0, function* () {
            const batchSize = exports.MAX_BATCH_REQUEST_SIZE;
            const requests = [];
            for (let i = 0; i < types.length; i += batchSize) {
                const batchTypes = types.slice(i, i + batchSize);
                requests.push(this.describeSObjectBatchRequest(batchTypes));
            }
            const results = yield Promise.all(requests);
            const fetchedSObjects = [].concat(...results);
            return fetchedSObjects;
        });
    }
}
exports.SObjectDescribe = SObjectDescribe;
/**
 * Convert jsforce's complete sobject metadata to our internal (smaller) SObject representation
 *
 * @param describeSObject full metadata of an sobject, as returned by the jsforce's sobject/describe api
 * @returns SObject containing a subset of DescribeSObjectResult information
 */
function toMinimalSObject(describeSObject) {
    return Object.assign({ fields: describeSObject.fields
            ? describeSObject.fields.map(toMinimalSObjectField)
            : [] }, pick(describeSObject, 'label', 'childRelationships', 'custom', 'name', 'queryable'));
}
exports.toMinimalSObject = toMinimalSObject;
function toMinimalSObjectField(describeField) {
    return pick(describeField, 'aggregatable', 'custom', 'defaultValue', 'extraTypeInfo', 'filterable', 'groupable', 'inlineHelpText', 'label', 'name', 'nillable', 'picklistValues', 'referenceTo', 'relationshipName', 'sortable', 'type');
}
function pick(obj, ...keys) {
    const ret = {};
    keys.forEach(key => {
        ret[key] = obj[key];
    });
    return ret;
}
//# sourceMappingURL=sObjectDescribe.js.map