"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const os_1 = require("os");
const path = require("path");
const declarationGenerator_1 = require("./declarationGenerator");
exports.TYPESCRIPT_TYPE_EXT = '.d.ts';
const TYPING_PATH = ['typings', 'lwc', 'sobjects'];
class TypingGenerator {
    constructor() {
        this.declGenerator = new declarationGenerator_1.DeclarationGenerator();
    }
    generate(output) {
        const typingsFolderPath = path.join(output.sfdxPath, ...TYPING_PATH);
        this.generateTypes([...output.getStandard(), ...output.getCustom()], typingsFolderPath);
    }
    generateTypes(sobjects, targetFolder) {
        if (!fs.existsSync(targetFolder)) {
            fs.mkdirSync(targetFolder, { recursive: true });
        }
        for (const sobj of sobjects) {
            if (sobj.name) {
                const sobjDefinition = this.declGenerator.generateSObjectDefinition(sobj);
                this.generateType(targetFolder, sobjDefinition);
            }
        }
    }
    generateType(folderPath, definition) {
        const typingPath = path.join(folderPath, `${definition.name}${exports.TYPESCRIPT_TYPE_EXT}`);
        if (fs.existsSync(typingPath)) {
            fs.unlinkSync(typingPath);
        }
        fs.writeFileSync(typingPath, this.convertDeclarations(definition), {
            mode: 0o444
        });
        return typingPath;
    }
    convertDeclarations(definition) {
        const className = definition.name;
        let declarations = Array.from(definition.fields);
        // sort, but filter out duplicates
        // which can happen due to childRelationships w/o a relationshipName
        declarations.sort((first, second) => {
            return first.name || first.type > second.name || second.type ? 1 : -1;
        });
        declarations = declarations.filter((value, index, array) => {
            return !index || value.name !== array[index - 1].name;
        });
        const declarationLines = declarations
            .filter(decl => !this.isCollectionType(decl.type))
            .map(decl => this.convertDeclaration(className, decl))
            .join(`${os_1.EOL}`);
        return declarationLines + `${os_1.EOL}`;
    }
    isCollectionType(fieldType) {
        return (fieldType.startsWith('List<') ||
            fieldType.startsWith('Set<') ||
            fieldType.startsWith('Map<'));
    }
    convertDeclaration(objName, decl) {
        const typingType = this.convertType(decl.type);
        const content = `declare module "@salesforce/schema/${objName}.${decl.name}" {
  const ${decl.name}:${typingType};
  export default ${decl.name};
}`;
        return content;
    }
    convertType(fieldType) {
        switch (fieldType) {
            case 'Boolean':
                return 'boolean';
            case 'String':
                return 'string';
            case 'Decimal':
            case 'Double':
            case 'Integer':
            case 'Long':
            case 'Number':
                return 'number';
        }
        return 'any';
    }
}
exports.TypingGenerator = TypingGenerator;
//# sourceMappingURL=typingGenerator.js.map