"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const os_1 = require("os");
const path = require("path");
const shelljs_1 = require("shelljs");
const constants_1 = require("../constants");
const messages_1 = require("../messages");
const types_1 = require("../types");
const declarationGenerator_1 = require("./declarationGenerator");
exports.INDENT = '    ';
exports.APEX_CLASS_EXTENSION = '.cls';
const REL_BASE_FOLDER = [constants_1.TOOLS_DIR, constants_1.SOBJECTS_DIR];
class FauxClassGenerator {
    constructor(selector, relativePath) {
        this.sobjectSelector = selector;
        this.relativePath = relativePath;
        this.declGenerator = new declarationGenerator_1.DeclarationGenerator();
        if (selector !== types_1.SObjectCategory.STANDARD &&
            selector !== types_1.SObjectCategory.CUSTOM) {
            throw messages_1.nls.localize('unsupported_sobject_category', String(selector));
        }
    }
    static fieldDeclToString(decl) {
        return `${FauxClassGenerator.commentToString(decl.comment)}${exports.INDENT}${decl.modifier} ${decl.type} ${decl.name};`;
    }
    // VisibleForTesting
    static commentToString(comment) {
        // for some reasons if the comment is on a single line the help context shows the last '*/'
        return comment
            ? `${exports.INDENT}/* ${comment.replace(/(\/\*+\/)|(\/\*+)|(\*+\/)/g, '')}${os_1.EOL}${exports.INDENT}*/${os_1.EOL}`
            : '';
    }
    generate(output) {
        const outputFolderPath = path.join(output.sfdxPath, ...REL_BASE_FOLDER, this.relativePath);
        if (!this.resetOutputFolder(outputFolderPath)) {
            throw messages_1.nls.localize('no_sobject_output_folder_text', outputFolderPath);
        }
        const sobjects = this.sobjectSelector === types_1.SObjectCategory.STANDARD
            ? output.getStandard()
            : output.getCustom();
        for (const sobj of sobjects) {
            if (sobj.name) {
                const sobjDefinition = this.declGenerator.generateSObjectDefinition(sobj);
                this.generateFauxClass(outputFolderPath, sobjDefinition);
            }
        }
    }
    // VisibleForTesting
    generateFauxClass(folderPath, definition) {
        if (!fs.existsSync(folderPath)) {
            fs.mkdirSync(folderPath);
        }
        const fauxClassPath = path.join(folderPath, `${definition.name}${exports.APEX_CLASS_EXTENSION}`);
        fs.writeFileSync(fauxClassPath, this.generateFauxClassText(definition), {
            mode: 0o444
        });
        return fauxClassPath;
    }
    // VisibleForTesting
    generateFauxClassText(definition) {
        let declarations = Array.from(definition.fields);
        const className = definition.name;
        // sort, but filter out duplicates
        // which can happen due to childRelationships w/o a relationshipName
        declarations.sort((first, second) => {
            return first.name || first.type > second.name || second.type ? 1 : -1;
        });
        declarations = declarations.filter((value, index, array) => {
            return !index || value.name !== array[index - 1].name;
        });
        const classDeclaration = `${declarationGenerator_1.MODIFIER} class ${className} {${os_1.EOL}`;
        const declarationLines = declarations
            .map(FauxClassGenerator.fieldDeclToString)
            .join(`${os_1.EOL}`);
        const classConstructor = `${exports.INDENT}${declarationGenerator_1.MODIFIER} ${className} () ${os_1.EOL}    {${os_1.EOL}    }${os_1.EOL}`;
        const generatedClass = `${messages_1.nls.localize('class_header_generated_comment')}${classDeclaration}${declarationLines}${os_1.EOL}${os_1.EOL}${classConstructor}}`;
        return generatedClass;
    }
    resetOutputFolder(pathToClean) {
        if (fs.existsSync(pathToClean)) {
            shelljs_1.rm('-rf', pathToClean);
        }
        if (!fs.existsSync(pathToClean)) {
            shelljs_1.mkdir('-p', pathToClean);
            return fs.existsSync(pathToClean);
        }
        return true;
    }
}
exports.FauxClassGenerator = FauxClassGenerator;
//# sourceMappingURL=fauxClassGenerator.js.map