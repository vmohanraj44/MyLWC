"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const constants_1 = require("../constants");
const messages_1 = require("../messages");
class SObjectTransformer {
    constructor(emitter, retrievers, generators, cancellationToken) {
        this.generators = [];
        this.emitter = emitter;
        this.generators = generators;
        this.retrievers = retrievers;
        this.cancellationToken = cancellationToken;
        this.result = { data: { cancelled: false } };
    }
    transform(projectPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const projectFile = path.join(projectPath, constants_1.SFDX_PROJECT_FILE);
            if (!fs.existsSync(projectPath) || !fs.existsSync(projectFile)) {
                return this.errorExit(messages_1.nls.localize('no_generate_if_not_in_project', projectFile));
            }
            const output = this.initializeData(projectPath);
            for (const retriever of this.retrievers) {
                if (this.didCancel()) {
                    return this.cancelExit();
                }
                if (this.result.error) {
                    return this.errorExit(this.result.error.message);
                }
                try {
                    yield retriever.retrieve(output);
                }
                catch (err) {
                    return this.errorExit(err.message);
                }
            }
            for (const gen of this.generators) {
                if (this.didCancel()) {
                    return this.cancelExit();
                }
                if (this.result.error) {
                    return this.errorExit(this.result.error.message);
                }
                try {
                    gen.generate(output);
                }
                catch (err) {
                    return this.errorExit(err.message);
                }
            }
            this.result.data.standardObjects = output.getStandard().length;
            this.result.data.customObjects = output.getCustom().length;
            return this.successExit();
        });
    }
    initializeData(projectPath) {
        const output = {
            addTypeNames: names => {
                output.typeNames = output.typeNames.concat(names);
            },
            getTypeNames: () => output.typeNames,
            addStandard: defs => {
                output.standard = output.standard.concat(defs);
                this.result.data.standardObjects = output.standard.length;
                this.logSObjects('Standard', defs.length);
            },
            getStandard: () => output.standard,
            addCustom: defs => {
                output.custom = output.custom.concat(defs);
                this.result.data.customObjects = output.custom.length;
                this.logSObjects('Custom', defs.length);
            },
            getCustom: () => output.custom,
            setError: (message, stack) => {
                this.result.error = { message, stack };
            },
            sfdxPath: path.join(projectPath, constants_1.SFDX_DIR),
            typeNames: [],
            custom: [],
            standard: []
        };
        return output;
    }
    didCancel() {
        if (this.cancellationToken &&
            this.cancellationToken.isCancellationRequested) {
            return true;
        }
        return false;
    }
    errorExit(message, stack) {
        this.emitter.emit(constants_1.STDERR_EVENT, `${message}\n`);
        this.emitter.emit(constants_1.ERROR_EVENT, new Error(message));
        this.emitter.emit(constants_1.EXIT_EVENT, constants_1.FAILURE_CODE);
        this.result.error = { message, stack };
        return Promise.reject(this.result);
    }
    successExit() {
        this.emitter.emit(constants_1.EXIT_EVENT, constants_1.SUCCESS_CODE);
        return Promise.resolve(this.result);
    }
    cancelExit() {
        this.emitter.emit(constants_1.EXIT_EVENT, constants_1.FAILURE_CODE);
        this.result.data.cancelled = true;
        return Promise.resolve(this.result);
    }
    logSObjects(sobjectKind, processedLength) {
        if (processedLength > 0) {
            this.emitter.emit(constants_1.STDOUT_EVENT, messages_1.nls.localize('processed_sobjects_length_text', processedLength, sobjectKind));
        }
    }
}
exports.SObjectTransformer = SObjectTransformer;
//# sourceMappingURL=sobjectTransformer.js.map