"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MODIFIER = 'global';
class DeclarationGenerator {
    generateSObjectDefinitions(sobjects) {
        const definitions = [];
        for (const sobject of sobjects) {
            const declarations = this.generateSObjectDefinition(sobject);
            definitions.push({
                name: sobject.name,
                fields: declarations.fields
            });
        }
        return definitions;
    }
    generateSObjectDefinition(sobject) {
        const declarations = [];
        if (sobject.fields) {
            for (const field of sobject.fields) {
                const decls = this.generateField(field);
                if (decls && decls.length > 0) {
                    for (const decl of decls) {
                        declarations.push(decl);
                    }
                }
            }
        }
        if (sobject.childRelationships) {
            for (const rel of sobject.childRelationships) {
                if (rel.relationshipName) {
                    const decl = this.generateChildRelationship(rel);
                    if (decl) {
                        declarations.push(decl);
                    }
                }
            }
            for (const rel of sobject.childRelationships) {
                // handle the odd childRelationships last (without relationshipName)
                if (!rel.relationshipName) {
                    const decl = this.generateChildRelationship(rel);
                    if (decl) {
                        declarations.push(decl);
                    }
                }
            }
        }
        return { name: sobject.name, fields: declarations };
    }
    stripId(name) {
        if (name.endsWith('Id')) {
            return name.slice(0, name.length - 2);
        }
        else {
            return name;
        }
    }
    capitalize(input) {
        return input.charAt(0).toUpperCase() + input.slice(1);
    }
    getTargetType(describeType) {
        const gentype = DeclarationGenerator.typeMapping.get(describeType);
        return gentype ? gentype : this.capitalize(describeType);
    }
    getReferenceName(name, relationshipName) {
        return relationshipName ? relationshipName : this.stripId(name);
    }
    generateChildRelationship(rel) {
        const name = this.getReferenceName(rel.field, rel.relationshipName);
        return {
            modifier: exports.MODIFIER,
            type: `List<${rel.childSObject}>`,
            name
        };
    }
    generateField(field) {
        const decls = [];
        const comment = field.inlineHelpText;
        let genType = '';
        if (!field.referenceTo || field.referenceTo.length === 0) {
            // should be a normal field EXCEPT for external lookup & metadata relationship
            // which is a reference, but no referenceTo targets
            if (field.extraTypeInfo === 'externallookup') {
                genType = 'String';
            }
            else {
                genType = this.getTargetType(field.type);
            }
            decls.push(Object.assign({
                modifier: exports.MODIFIER,
                type: genType,
                name: field.name
            }, comment ? { comment } : {}));
        }
        else {
            const name = this.getReferenceName(field.name, field.relationshipName);
            decls.push(Object.assign({
                modifier: exports.MODIFIER,
                name,
                type: field.referenceTo && field.referenceTo.length > 1
                    ? 'SObject'
                    : `${field.referenceTo}`
            }, comment ? { comment } : {}));
            // field.type will be "reference", but the actual type is an Id for Apex
            decls.push(Object.assign({
                modifier: exports.MODIFIER,
                name: field.name,
                type: 'Id'
            }, comment ? { comment } : {}));
        }
        return decls;
    }
}
exports.DeclarationGenerator = DeclarationGenerator;
DeclarationGenerator.typeMapping = new Map([
    ['string', 'String'],
    ['double', 'Double'],
    ['reference', ''],
    ['boolean', 'Boolean'],
    ['currency', 'Decimal'],
    ['date', 'Date'],
    ['datetime', 'Datetime'],
    ['email', 'String'],
    ['location', 'Location'],
    ['percent', 'Double'],
    ['phone', 'String'],
    ['picklist', 'String'],
    ['multipicklist', 'String'],
    ['textarea', 'String'],
    ['encryptedstring', 'String'],
    ['url', 'String'],
    ['id', 'Id'],
    // note that the mappings below "id" only occur in standard SObjects
    ['base64', 'Blob'],
    ['address', 'Address'],
    ['int', 'Integer'],
    ['anyType', 'Object'],
    ['combobox', 'String'],
    ['time', 'Time'],
    // TBD what are these mapped to and how to create them
    // ['calculated', 'xxx'],
    // ['masterrecord', 'xxx'],
    ['complexvalue', 'Object']
]);
//# sourceMappingURL=declarationGenerator.js.map